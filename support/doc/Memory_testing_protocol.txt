***************************************************************************
************* Kernel-level memory management testing protocol *************
***************************************************************************

0/ Preliminary remarks
    This protocol does not test the performance of each component of the kernel's memory management
    system, only their qualitative behaviors. To prevent the test from freezing if the tested
    component locks up, implementations should include a "watchdog" system in their final release as
    soon as possible. This watchdog would check if an individual test case is lasting more than a
    second, which is plain abnormal for simple RAM manipulations like these ones. In this case, the
    test is aborted, and considered as failed.

    Several parts of the protocol require the testing code to have access to the internal state of
    the VirMemManager, PhyMemManager, and MemAllocator classes. This should be done by using a
    structure which mimicks their internal organization and some form of casting.

    Please that note that we're testing internal kernel components here, which are only directly
    accessed by trusted kernel code and never by user process. Therefore, it is futile to implement
    full parameter checking at this level. It has not been done, and it should not be tested except
    in directly specified cases.

    These tests are supposed to be run before memory management has been initialized. Otherwise,
    they might smash its internal data, which would result in them malfunctioning

I/  Initialization
    1. Meta (testing the test itself)
        * Check that we're testing the good version of PhyMemManager (PHYMEMMANAGER_VERSION)
        * Check that we're testing the good version of VirMemManager (VIRMEMMANAGER_VERSION)
        * Check that we're testing the good version of MemAllocator (MEMALLOCATOR_VERSION)
    2. PhyMemManager initialization
        * Initialize a PhyMemManager object
        * Check that mmap_mutex is available
        * Check that the fundamental assumptions about phy_mmap are respected
            -Locations and sizes must be page-aligned (aligned on a PG_SIZE boundary)
            -Map items should not overlap
            -Locations must be sorted properly
        * Check that kmmap is properly mapped in phy_mmap
            -Map items with a page-aligned version of the beginning and the end must be present
            -kmmap items which are not of nature NATURE_RES must be marked allocatable, items of
                nature NATURE_RES must be marked non-allocatable
            -Regions of phy_mmap including NATURE_BSK or NATURE_KNL items must be marked as
                allocated to the kernel, others must be marked as free (apart from exception below)
        * Sole accepted difference is a part of initially free memory which is allocated by
            PhyMemMap to store its management structures. Check that it is allocated properly.
        * Check that all map items are allocated before use, without leaks
            -The items of phy_mmap, must be stacked at the beginning of the allocated space
            -What remains of the allocated space must be put in free_mapitems
        * Check that free_mapitems are initialized properly (all parameters equal to their initial
            value, except for next_buddy which is the next item or zero at the end of the list)
        * x86_64 : Check that phy_highmmap, free_lowmem and free_highmem have a good value and that
            linking via next_buddy is done properly
    3. VirMemManager initialization
        * Initialize a VirMemManager object
        * Check phymem-virmem integration :
            -The phymem pointer of virmem must be correct
            -Two physical pages must have been allocated to kernel during virmem initialization
        * Check that maplist_mutex is free
        * Check the state of map_list
            -There must be a single entry
            -map_owner must be PID_KERNEL
            -map_pointer must be NULL
            -mutex must be free
            -x86_64 : pml4t_location must agree with the result derivated from CR3 by get_pml4t()
        * Check that map and list items are properly allocated
        * Check the information about kernel physical and virtual locations
    4. MemAllocator initialization
        * Initialize a MemAllocator object
        * Check phymem-virmem-mallocator integration :
            -The phymem and virmem pointers must be correct
            -Two physical pages must have been allocated to PID_KERNEL during initialization
        * Check that map_list, knl_free_map and knl_busy_map are all NULL
        * Check that map and list items are properly allocated
        * Check that knl_mutex and maplist_mutex are available
        * Setup kalloc with our MemAllocator, so that we may use it later

II/ PhyMemManager
    1. Contiguous memory allocation and liberation with and without free items merging
        * Put PhyMemManager in a state with two consecutive free pages, save this state.
        * Allocate a contiguous chunk of two pages, check the returned result
            -The pointer must be nonzero
            -location must be page-aligned
            -size must be 2*PG_SIZE
            -owners must only include the PID to which the page has been allocated
            -allocatable must be true
            -next_buddy must be NULL
            -next_mapitem must be nonzero
        * Check modifications to PhyMemManager's state
            -The two previously free pages must have been merged in the returned chunk
            -In free_*mem, the chunk must have been replaced with the next item
            -free_mapitems must be one item longer, as the second free page has been merged with the
             first one
            -Everything else should be identical to the previous state
        * Free the previously allocated chunk, using the pointer-based version of free()
        * Check modifications to PhyMemManager's state
            -The chunk must now have no owner
            -It must have been moved in the beginning of free_*mem
            -Everything else must be identical
        * Allocate a contiguous chunk of two pages again, check the result again
        * Check modifications to PhyMemManager's state
            -The chunk must have been allocated in the previously freed space
            -As before, it must have disappeared from free_*mem
            -Everything else should be identical
        * Free the chunk in the same way, modifications to PhyMemManager's state should be the same
        * Free the saved state of PhyMemManager
    2. Contiguous memory allocation with free item splitting
        * Put PhyMemManager in a state with a 3 pages long free chunk, save this state
        * Allocate a contiguous chunk of two pages, check the result
        * Check modifications to PhyMemManager's state
            -The previously free chunk should have been split in two : the allocated 2pg chunk, and
             a free page
            -free_*mem must point to the free page
            -free_mapitems should be one item shorter (one new map item is required for splitting)
            -Everything else should be identical
        * Free the chunk in the same way, modifications to PhyMemManager's state should be the same
        * Free the saved state of PhyMemManager
    3. Contiguous memory allocation in non-contiguous free memory
        * Put PhyMemManager in a state with one free page, then an allocated page, then a two pages
          long free chunk, and save this state.
        * Allocate a contiguous chunk of two pages, check the result
        * Check modifications to PhyMemManager's state
            -The free page must have been left untouched, the free chunk after should have been
             fully allocated.
            -free_*mem should still point to the free page, everything else should be identical
        * Free the chunk, check modifications to PhyMemManager's state
            -The chunk must now have no owner
            -free_*mem should still point to the free page, followed by the now-free 2pg chunk
            -Everything else should be identical
        * Free the saved PhyMemManager state
    4. Non-contiguous memory allocation
        * Go back to the beginning and start over, but with non-contiguous chunk allocation and the
          location-based variant of free this time. Results should be identical except for the last
          test, whose expected results are described below
        * The result of the allocation function should be modified as follows
            -PG_SIZE size
            -next_buddy points to another similar page of memory, which itself has next_buddy = NULL
        * PhyMemManager's state should be modified by allocation as follows
            -The free page should have turned into the first page of the allocated chunk
            -The free chunk should have been split in two pages, first one going in the second part
             of the alocated chunk, second part going in free_*map.
            -free_mapitems should be one item shorter
            -Everything else should be perfectly identical
        * After free is being applied, PhyMemManager's state should be modified as follows
            -Owners of both parts of the allocated chunk have been cleared
            -They should have been put in the beginning of free_*mem, in the right order
            -Everything else should be identical
        * Free the saved state, we're done
    5. Sharing functions
        * Allocate a page
        * Check that adding an owner works properly (owner is added to the owners field of the page,
          nothing else has changed)
        * Remove both owners from the page, check that it is freed properly by re-allocating it
    6. Allocation of a reserved chunk
        * Find a reserved chunk in phy_mmap
        * Try to allocate it with alloc_resvchunk
        * Check that it works
        * Try to allocate it to another PID with alloc_resvchunk
        * Check that it didn't work
        * Check that owneradd does work
        * Free the chunk, check that it went back to its initial state
    7. Finding a chunk
        * Try to find the first chunk of phy_mmap with find_this()
        * Check results
        * Try to find the second chunk of phy_mmap with find_this()
        * Check results
        * Try to find the last chunk of phy_mmap with find_this()
        * Check results
    8. kill() test
        * Restart one test which allocates some data, try to kill a process, check that all of its
          data has been liberated.
        * Same thing, but with the kernel. Check that its data has *not* been liberated.
    9. Internal allocator
        * Check that sizeof(PhyMemMap) is a power of 2
        * Count the number of spare PhyMemMaps in free_mapitem, allocate as much pages
        * Check that no new page has been allocated by the internal allocator and that free_mapitems
          is now empty
        * Allocate one more page, check that the number of items in free_mapitems is correct and
          that two pages have been effectively allocated (one being allocated by the internal
          allocator in the name of the kernel)
        * Free everything, allocate a big chunk to put all the previously used map items back in
          free_mapitems, check that they are all properly cleaned up before being put in
          free_mapitems
    a. x86_64-specific
        * Repeat tests with the low memory allocators, when it does apply.

III/VirMemManager
    1. Basic paging
        * Save VirMemManager and PhyMemManager state
        * Allocate a page with phymem
        * Try to map it in PID_KERNEL's address space
        * Check that it fails and that the state of phymem and VirMemManager is left unchanged
        * Try to map it in a new PID's address space
        * Check the returned result :
            -The pointer should be nonzero
            -location must be nonzero
            -size must be PG_SIZE
            -flags must be RW-P
            -owner must be nonzero
            -points_to must be the previously allocated page
            -next_buddy doit être NULL
            -next_mapitem doit être NULL
        * Check map_list state
            -A single new item, located after that of PID_KERNEL, pointed by the previously
             mentioned "owner" field
            -map_owner must match the PID given as a parameter to map()
            -map_pointer must map the physical page given as a parameter to map().
             In that map, there should be a kernel memory-mapped as a global page, too. With
             VMEM_FLAG_K for protection.
            -x86_64 : pml4t_location must be nonzero and point a freshly allocated page of physical
             memory allocated to PID_KERNEL
            -mutex must be available
        * Check paging structures state. For x86_64...
            -PG_SIZE(4KB)-sized paging must be in use
            -A page translation, coherent with the previous results, must be present
            -The kernel must be properly memory-mapped in the process' address space
            -Everything else must be zero
    2. Freeing and process data cleanup
        * Free the previously mapped page
        * Check that the result is a nonzero pointer
        * Check that PhyMemManager and VirMemManager are back to their initial state at the
          beginning of 2.
        * Check that paging structures have been fully zeroed-out before liberation
    3. Chunk mapping
        * Do the following successive allocation test, checking the results of each operation
            -Allocate page 1
            -Allocate page 2
            -Free page 1
            -Allocate page 3
            -Allocate page 4
            -Free page 2
            -Allocate page 5
            -Free pages 3, 4, 5
        * Allocate a chunk which is larger than a page and map it
        * Check VirMemManager state, page translations, and result, like in 1.
        * Free, check the result like in 4.
        * Using the same tricks as in I/6., allocate and map a non-contiguous chunk. Check results
        * Free it, check results
    4. Flags
        * Try to map a page with all possible combinations of R, W, X, and P flags
        * Check the flags are properly set up in the map and paging structures
        * For each combination, try to modify the flags in all possible ways, and check it works
        * Repeat with contiguous and non-contiguous multi-page chunks.
        * Free everything
    5. Allocation of all memory
        * Allocate a page and map it in one new PID's address space, so that management structures
          for that PID are created
        * Allocate all free memory as before, then try to map it in that PID's address space
        * Check that the operation went as planned
        * Free the chunk, allocate all memory minus one page, try to allocate and map that page
        * Check that the operation went as planned
        * Free everything
    6. Multiple process management
        * Map a page for two different processes
        * Check that it worked
        * Free the mapped page for the first process
        * Check that it worked
        * Free the mapped page for the second process
        * Check that it worked
    7. kill() test
        * Restart one test which allocates some data, try to kill a process, check that all of its
          data has been liberated.
        * Same thing, but with the kernel. Check that nothing happens
    8. Internal allocator
        * Check that sizeof(VirMemMap) and sizeof(VirMapList) are powers of 2
        * Count the number of free_mapitems
        * Map a page that amount of times to a single process
        * Check that no new physical page has been allocated and that free_mapitems is now empty
        * Map it one more time, check the number of newly allocated free_mapitems and that they are
          stored in a single newly allocated physical page
        * Free everything, check that VirMemMaps are properly cleaned up before being put back in
          free_mapitems
        * Same test with a new PID for each mapped page, to test the management of free_listitems.
          Remember that paging structures are allocated for each new process, too
    9. x86_64-specific
        * Try to allocate data crossing the boundary between two PTs, then between two PDs, then
          between two PDPTs. Check that the result is correct and that the paging structures are
          all zeroed out and freed when their time has come
        * Check that cr3_value() works

IV/ MemAllocator
    1. Allocating/freeing kernel data
        * Allocate one byte of memory to the kernel
        * Check that the result is nonzero and page-aligned
        * Check MemAllocator's state
            -knl_busy_mem must include one chunk at the previous location, of size 1
            -knl_free_mem must include one chunk located one byte later, of size PG_SIZE-1
            -There must be two less items in free_mapitems
            -The rest of MemAllocator's state must be unchanged
        * Check the rest of the memory management system
            -VirMemManager must be left unchanged
            -PhyMemManager must have a newly kernel-allocated page at the right location
        * Free this byte
        * Check that MemAllocator went back to its initial state
        * Check that VirMemManager is unchanged and that the page was liberated in PhyMemManager
    2. Allocating/freeing user data
        * Allocate a byte to some PID, check that the result is PG_SIZE
        * Check MemAllocator's state :
            -map_list must be nonzero
            -map_list->map_owner must be the right PID
            -map_list->free_map must include a single item, located at PG_SIZE, 1 byte long
            -map_list->busy_map must include a single item at PG_SIZE+1, PG_SIZE-1 bytes long
            -map_list->next_item must be NULL
            -map_list->mutex must be available
            -There must be two less items in free_mapitems and one less in free_listitems
            -The rest of MemAllocator's state must be left unchanged
        * Check the rest of the memory management system
            -VirMemManager must have data for this process, with a page at PG_SIZE
            -PhyMemManager must have a newly allocated page for this process, with VirMemManager's
             and paging structure's data pointing to it
        * Free this byte
        * Check that MemAllocator went back to its initial state
        * Check that VirMemManager went back to its initial state and that the page was freed by
          PhyMemManager
    3. Sub-page allocation
        * Allocate to some PID a number of mid-sized (~0x100 bytes) objects whose sizes add up to
          PG_SIZE, check that the sole observed things compared with the previous byte allocation
          are a data transfer from this PID's busy_map to its free_map, and a gradual depletion of
          the stock of free_mapitems without any leak ocurring
        * Free the first allocated object and try to re-allocate it, check the results
        * Free it again, then allocate a number of small things whose size add up to its size. Check
          the results
        * In each case, try to allocate an object which is too big for the available space in
          free_map. Check that in this case, the free_map chunk is left untouched and a new page
          is allocated instead
        * Free everything and do the same tests, but allocating objects for the kernel this time
    4. Allocating accross several pages
        * Allocate something bigger than one page but smaller than two to a PID
        * Check that we get the expected result, then free the data and check it works well
        * Same tests, but allocating objects for the kernel this time
    5. Allocating all memory
        * Allocate all memory to an already existing PID
        * Check that the operation was successful and had the expected results
        * Try to allocate memory to this PID and others in all possible ways, check that it fails
          and that the state of MemAllocator, PhyMemManager and VirMemManager are not modified
        * Free the big chunk, then try to allocate all memory but one page and then the page
        * Check that everything went well
        * Free everything, check that the memory management system goes back to its initial state
        * Same tests, but allocating objects for the kernel this time
    6. Flags
        * Repeat previous tests with all combinations of R, W, X, and P flags. Check that
            -The pages are allocated with the correct flags in VirMemManager for usual PIDs
            -Allocation fails without a single change to the system's state when kernel is the
             target and flags are not RW-P. Allocation works properly when kernel is the sender and
             flags are not RW-P
        * Try to do sub-page allocation with objects having different flags. Check that they are not
          allocated together in a single page, but that new pages are created instead.
    7. Multiple process management
        * Allocate pages for two new processes
        * Check that it works as expected
        * Delete the page of the first process, check that it worked as planned
        * Delete the page of the second process, check that it worked as planned
    8. Sharing functions
        * For a PID which already has a byte allocated, use alloc_shareable() to allocate objects
          more than one page but less than 2 pages long, one page long, and less than one page long.
          Check that in each case, new pages are allocated, and that the remaining space after
          allocation is not put in free_map.
        * Check that owneradd() works properly. It should take a chunk of the busy_map of the
          initial process, map its content in the address pace of another process, and put it in the
          busy_map of that other process. Nothing more, nothing less.
        * Check that free()-ing a shared page does in fact only remove the relevant owner in
          PhyMemManager, and does not actually free the page for all owners.
        * Same tests, but with the kernel as the allocating process, sender, or recipient
    9. kill() test
        * Restart one test which allocates some data, try to kill a process, check that all of its
          data has been liberated.
        * Same thing, but with the kernel. Check that its data has *not* been liberated.
    a. Internal allocator
        * Check that sizeof(MallocMap), sizeof(KnlMallocMap) and sizeof(MallocPIDList) are powers of
          2, and that sizeof(MallocMap) == sizeof(KnlMallocMap) (going from one to the other should
          be a matter of casting a pointer)
        * Count the number of free_mapitems
        * Allocate that number of bytes to a process which already owns a byte of data, one by one
        * Check that the state of VirMemManager and PhyMemManager has not changed and that
          free_mapitems is now empty
        * Allocate one more byte, check the number of newly created free_mapitems and the proper
          allocation of a new physical page where they are stored
        * Free everything, check that the free_mapitems go back at their place and are cleaned up
          before being put there
        * Same tests, but with the kernel as the allocating process
        * Same tests, but with different PIDs at each time, in order to test the management of
          free_listitems