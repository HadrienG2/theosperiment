***************************************************************************
************* Kernel-level memory management testing protocol *************
***************************************************************************

0/ Preliminary remarks
    This protocol does not test the performance of each component of the kernel's memory management
    system, only their qualitative behaviors. To prevent the test from freezing if the tested
    component locks up, implementations should include a "watchdog" system in their final release as
    soon as possible. This watchdog would check if an individual test case is lasting more than a
    second, which is plain abnormal for simple RAM manipulations like these ones. In this case, the
    test is aborted, and considered as failed.

    Several parts of the protocol require the testing code to have access to the internal state of
    the VirMemManager, PhyMemManager, and MemAllocator classes. This should be done by using a
    structure which mimicks their internal organization and some form of casting.

    Please that note that we're testing internal kernel components here, which are only directly
    accessed by trusted kernel code and never by user process. Therefore, it is futile to implement
    full parameter checking at this level. It has not been done, and it should not be tested except
    in directly specified cases.

    These tests are supposed to be run before memory management has been initialized. Otherwise,
    they might smash its internal data, which would result in them malfunctioning
    
    This protocol tests PhyMemManager version 2, VirMemManager version 1, and MemAllocator version 1

I/  Initialization
    1. Meta (testing the test itself)
        * Check that we're testing the good version of PhyMemManager (PHYMEMMANAGER_VERSION)
        * Check that we're testing the good version of VirMemManager (VIRMEMMANAGER_VERSION)
        * Check that we're testing the good version of MemAllocator (MEMALLOCATOR_VERSION)
    2. PhyMemManager initialization
        * Initialize a PhyMemManager object
        * Check that mmap_mutex is available
        * Check that the fundamental assumptions about phy_mmap are respected
            -Locations and sizes must be page-aligned (aligned on a PG_SIZE boundary)
            -Map items should not overlap
            -Locations must be sorted properly
        * Check that kmmap is properly mapped in phy_mmap
            -Map items with a page-aligned version of the beginning and the end must be present
            -kmmap items which are not of nature NATURE_RES must be marked allocatable, items of
                nature NATURE_RES must be marked non-allocatable
            -Regions of phy_mmap including NATURE_BSK or NATURE_KNL items must be marked as
                allocated to the kernel, others must be marked as free (apart from exception below)
        * Sole accepted difference is a part of initially free memory which is allocated by
            PhyMemMap to store its management structures. Check that it is allocated properly.
        * Check that all map items are allocated before use, without leaks
            -The items of phy_mmap, must be stacked at the beginning of the allocated space
            -What remains of the allocated space must be put in free_mapitems
        * Check that free_mapitems are initialized properly (all parameters equal to their initial
            value, except for next_buddy which is the next item or zero at the end of the list)
        * x86_64 : Check that phy_highmmap, free_lowmem and free_highmem have a good value and that
            linking via next_buddy is done properly
    3. VirMemManager initialization
        * Initialize a VirMemManager object
        * Check phymem-virmem integration :
            -The phymem pointer of virmem must be correct
            -Two physical pages must have been allocated to kernel during virmem initialization
        * Check that maplist_mutex is free
        * Check the state of map_list
            -There must be a single entry
            -map_owner must be PID_KERNEL
            -map_pointer must be NULL
            -mutex must be free
            -x86_64 : pml4t_location must agree with the result derivated from CR3 by get_pml4t()
        * Check that map and list items are properly allocated
        * Check the information about kernel physical and virtual locations
    4. MemAllocator initialization
        * Initialize a MemAllocator object
        * Check phymem-virmem-mallocator integration :
            -The phymem and virmem pointers must be correct
            -Two physical pages must have been allocated to PID_KERNEL during initialization
        * Check that map_list, knl_free_map and knl_busy_map are all NULL
        * Check that map and list items are properly allocated
        * Check that knl_mutex and maplist_mutex are available
        * Setup kalloc with our MemAllocator

II/ PhyMemManager
    1. Contiguous memory allocation and liberation
        * Put PhyMemManager in a state with two consecutive free pages, save it
        * Allocate a contiguous chunk of two pages, check the returned result
            -The pointer must be nonzero
            -location must be page-aligned
            -size must be 2*PG_SIZE
            -owners must only include the PID to which the page has been allocated
            -allocatable must be true
            -next_buddy must be NULL
            -next_mapitem must be nonzero
            -shareable must be false
        * Check modifications to PhyMemManager's state
            -The two previously free pages must have been merged in the returned chunk
            -In free_*mem, the chunk must have been replaced with the next item
            -free_mapitems must be one item longer, as the second free page has been merged with the
             first one
            -Everything else should be identical to the previous state
        * Use pointer-based free() to free the chunk. Check that result is true, and that
          PhyMemManager's state has been modified well
            -The chunk must now have no owner
            -It must have been moved in the beginning of free_*mem, and must have the former
             free_*mem as its next buddy
            -Everything else must be identical
        * Allocate a contiguous chunk of two pages again, check the result again
        * Check modifications to PhyMemManager's state
            -The chunk must have been allocated in the previously freed space
            -It must have no buddy
            -As before, it must have disappeared from free_*mem
            -Everything else should be identical
        * Free the chunk with the address-based version of free. Modifications to PhyMemManager's
         state should be the same
    2. Contiguous memory allocation with free item splitting
        * Put PhyMemManager in a state with a 3 pages long free chunk, save it
        * Allocate a contiguous chunk of two pages, check the result
        * Check modifications to PhyMemManager's state
            -The previously free chunk should have been split in two : the allocated 2pg chunk, and
             a free page
            -free_*mem must point to the free page
            -free_mapitems should be one item shorter (one new map item is required for splitting)
            -Everything else should be identical
        * Free the chunk in the same way, modifications to PhyMemManager's state should be the same
    3. Contiguous memory allocation in non-contiguous free memory
        * Put PhyMemManager in a state with one free page, then an allocated page, then two free
          pages, and save this state.
        * Allocate a contiguous chunk of two pages, check the result
        * Check modifications to PhyMemManager's state
            -The free page must have been left untouched, the free chunk after should have been
             fully allocated in the two pages afterwards.
            -free_*mem should still point to the free page
            -free_mapitems should be one item longer due to some merging
            -Everything else should be identical
        * Free the chunk, check modifications to PhyMemManager's state
            -The chunk must now have no owner
            -free_*mem should still point to the free page, followed by the now-free 2pg chunk
            -Everything else should be identical
    4. Non-contiguous memory allocation
        * Go back to the beginning and start over, but with non-contiguous chunk allocation and the
          location-based variant of free this time. Results should be identical except for the last
          test, whose expected results are described below
        * The result of the allocation function should be modified as follows
            -PG_SIZE size
            -next_buddy points to another similar page of memory, which itself has next_buddy = NULL
        * PhyMemManager's state should be modified by allocation as follows
            -The free page should have turned into the first page of the allocated chunk
            -The free chunk should have been split in two pages, first one going in the second part
             of the alocated chunk, second part going in free_*map.
            -free_mapitems should be one item shorter
            -Everything else should be perfectly identical
        * After free is being applied, PhyMemManager's state should be modified as follows
            -Owners of both parts of the allocated chunk have been cleared
            -They should have been put in the beginning of free_*mem, in the right order
            -Everything else should be identical
    5. Sharing functions
        * Allocate a page, save PhyMemManager's state
        * Check that adding an owner works properly (owner is added to the owners field of the page,
          nothing else has changed)
        * Free the page, check that all owners are now gone
        * Allocate the page again, save PhyMemManager's state
        * Remove the page's owner, check that it is freed
    6. Allocation of a reserved (allocatable = false) chunk
        * Allocate a page, mark it as reserved, free it, make sure it's still reserved
          (this makes sure that there's a reserved free chunk around). Save phymem state.
        * Try to allocate the page with alloc_resvchunk(), check that it works (result and state)
        * Try to allocate it to another PID, check that it fails
        * Check that owneradd() and ownerdel() do work
        * Free the page, check that it went back to its initial state
    7. Finding a chunk
        * Try to find the first chunk of phy_mmap with find_thischunk()
        * Try to find the second chunk of phy_mmap with find_thischunk()
        * Try to find the last chunk of phy_mmap with find_thischunk()
    8. kill() test
        * Put PhyMemManager in a state with two consecutive free pages, save it
        * Allocate two pages to a process, then kill the process
        * Check that we went back to the initially saved state
        * Try to kill the kernel. Check that it fails.
    9. Internal allocator
        * Check that sizeof(PhyMemMap) is a power of 2
        * Check that all free map items are used before new ones are allocated
        * Allocate one more page. Check that the right number of free map items
          (PG_SIZE/sizeof(PhyMemMap)) is allocated when all free map items have been used, and that
          one and only one page of memory is allocated to the kernel in the process.
        * Allocate two pages, free them, and allocate a 2 pages chunk. Use it to check that map
          items are cleaned up before being put in free_mapitems
        * Start over with PIDs, making use of sharing functions to spend them.
    a. x86_64-specific
        * Repeat all allocation/liberation tests with the low memory allocators

III/VirMemManager
    1. Basic paging
        * Save VirMemManager and PhyMemManager state
        * Allocate a page with phymem
        * Try to map it in PID_KERNEL's address space
        * Check that it fails and that the state of phymem and VirMemManager is left unchanged
        * Try to map it in a new PID's address space
        * Check the returned result :
            -The pointer should be nonzero
            -location must be nonzero
            -size must be PG_SIZE
            -flags must be RW-P
            -owner must be nonzero
            -points_to must be the previously allocated page
            -next_buddy doit être NULL
            -next_mapitem doit être NULL
            -shareable must be false
        * Check map_list state
            -A single new item, located after that of PID_KERNEL, pointed by the previously
             mentioned "owner" field
            -map_owner must match the PID given as a parameter to map()
            -map_pointer must map the physical page given as a parameter to map().
             In that map, there should be a kernel memory-mapped as a global page, too. With
             VMEM_FLAG_K for protection.
            -x86_64 : pml4t_location must be nonzero and point a freshly allocated page of physical
             memory allocated to PID_KERNEL
            -mutex must be available
        * Check paging structures state. For x86_64...
            -PG_SIZE(4KB)-sized paging must be in use
            -A page translation, coherent with the previous results, must be present
            -The kernel must be properly memory-mapped in the process' address space
            -Everything else must be zero
    2. Freeing and process data cleanup
        * Free the previously mapped page
        * Check that the result is a nonzero pointer
        * Check that PhyMemManager and VirMemManager are back to their initial state at the
          beginning of 2.
        * Check that paging structures have been fully zeroed-out before liberation
    3. Chunk mapping
        * Do the following successive allocation test, checking the results of each operation
            -Allocate page 1
            -Allocate page 2
            -Free page 1
            -Allocate page 3
            -Allocate page 4
            -Free page 2
            -Allocate page 5
            -Free pages 3, 4, 5
        * Allocate a chunk which is larger than a page and map it
        * Check VirMemManager state, page translations, and result, like in 1.
        * Free, check the result like in 4.
        * Using the same tricks as in I/6., allocate and map a non-contiguous chunk. Check results
        * Free it, check results
    4. Flags
        * Try to map a page with all possible combinations of R, W, X, and P flags
        * Check the flags are properly set up in the map and paging structures
        * For each combination, try to modify the flags in all possible ways, and check it works
        * Repeat with contiguous and non-contiguous multi-page chunks.
        * Free everything
    5. Allocation of all memory
        * Allocate a page and map it in one new PID's address space, so that management structures
          for that PID are created
        * Allocate all free memory as before, then try to map it in that PID's address space
        * Check that the operation went as planned
        * Free the chunk, allocate all memory minus one page, try to allocate and map that page
        * Check that the operation went as planned
        * Free everything
    6. Multiple process management
        * Map a page for two different processes
        * Check that it worked
        * Free the mapped page for the first process
        * Check that it worked
        * Free the mapped page for the second process
        * Check that it worked
    7. kill() test
        * Restart one test which allocates some data, try to kill a process, check that all of its
          data has been liberated.
        * Same thing, but with the kernel. Check that nothing happens
    8. Internal allocator
        * Check that sizeof(VirMemMap) and sizeof(VirMapList) are powers of 2
        * Count the number of free_mapitems
        * Map a page that amount of times to a single process
        * Check that no new physical page has been allocated and that free_mapitems is now empty
        * Map it one more time, check the number of newly allocated free_mapitems and that they are
          stored in a single newly allocated physical page
        * Free everything, check that VirMemMaps are properly cleaned up before being put back in
          free_mapitems
        * Same test with a new PID for each mapped page, to test the management of free_listitems.
          Remember that paging structures are allocated for each new process, too
    9. x86_64-specific
        * Try to allocate data crossing the boundary between two PTs, then between two PDs, then
          between two PDPTs. Check that the result is correct and that the paging structures are
          all zeroed out and freed when their time has come
        * Check that cr3_value() works

IV/ MemAllocator
    1. Allocating/freeing kernel data
        * Allocate one byte of memory to the kernel
        * Check that the result is nonzero and page-aligned
        * Check MemAllocator's state
            -knl_busy_mem must include one chunk at the previous location, of size 1
            -knl_free_mem must include one chunk located one byte later, of size PG_SIZE-1
            -There must be two less items in free_mapitems
            -The rest of MemAllocator's state must be unchanged
        * Check the rest of the memory management system
            -VirMemManager must be left unchanged
            -PhyMemManager must have a newly kernel-allocated page at the right location
        * Free this byte
        * Check that MemAllocator went back to its initial state
        * Check that VirMemManager is unchanged and that the page was liberated in PhyMemManager
    2. Allocating/freeing user data
        * Allocate a byte to some PID, check that the result is PG_SIZE
        * Check MemAllocator's state :
            -map_list must be nonzero
            -map_list->map_owner must be the right PID
            -map_list->free_map must include a single item, located at PG_SIZE, 1 byte long
            -map_list->busy_map must include a single item at PG_SIZE+1, PG_SIZE-1 bytes long
            -map_list->next_item must be NULL
            -map_list->mutex must be available
            -There must be two less items in free_mapitems and one less in free_listitems
            -The rest of MemAllocator's state must be left unchanged
        * Check the rest of the memory management system
            -VirMemManager must have data for this process, with a page at PG_SIZE
            -PhyMemManager must have a newly allocated page for this process, with VirMemManager's
             and paging structure's data pointing to it
        * Free this byte
        * Check that MemAllocator went back to its initial state
        * Check that VirMemManager went back to its initial state and that the page was freed by
          PhyMemManager
    3. Sub-page allocation
        * Allocate to some PID a number of mid-sized (~0x100 bytes) objects whose sizes add up to
          PG_SIZE, check that the sole observed things compared with the previous byte allocation
          are a data transfer from this PID's busy_map to its free_map, and a gradual depletion of
          the stock of free_mapitems without any leak ocurring
        * Free the first allocated object and try to re-allocate it, check the results
        * Free it again, then allocate a number of small things whose size add up to its size. Check
          the results
        * In each case, try to allocate an object which is too big for the available space in
          free_map. Check that in this case, the free_map chunk is left untouched and a new page
          is allocated instead
        * Free everything and do the same tests, but allocating objects for the kernel this time
    4. Allocating accross several pages
        * Allocate something bigger than one page but smaller than two to a PID
        * Check that we get the expected result, then free the data and check it works well
        * Same tests, but allocating objects for the kernel this time
    5. Allocating all memory
        * Allocate all memory to an already existing PID
        * Check that the operation was successful and had the expected results
        * Try to allocate memory to this PID and others in all possible ways, check that it fails
          and that the state of MemAllocator, PhyMemManager and VirMemManager are not modified
        * Free the big chunk, then try to allocate all memory but one page and then the page
        * Check that everything went well
        * Free everything, check that the memory management system goes back to its initial state
        * Same tests, but allocating objects for the kernel this time
    6. Flags
        * Repeat previous tests with all combinations of R, W, X, and P flags. Check that
            -The pages are allocated with the correct flags in VirMemManager for usual PIDs
            -Allocation fails without a single change to the system's state when kernel is the
             target and flags are not RW-P. Allocation works properly when kernel is the sender and
             flags are not RW-P
        * Try to do sub-page allocation with objects having different flags. Check that they are not
          allocated together in a single page, but that new pages are created instead.
    7. Multiple process management
        * Allocate pages for two new processes
        * Check that it works as expected
        * Delete the page of the first process, check that it worked as planned
        * Delete the page of the second process, check that it worked as planned
    8. Sharing functions
        * For a PID which already has a byte allocated, use alloc_shareable() to allocate objects
          more than one page but less than 2 pages long, one page long, and less than one page long.
          Check that in each case, new pages are allocated, and that the remaining space after
          allocation is not put in free_map.
        * Check that owneradd() works properly. It should take a chunk of the busy_map of the
          initial process, map its content in the address pace of another process, and put it in the
          busy_map of that other process. It should only work on pages allocated with
          alloc_shareable(). Nothing more, nothing less.
        * Check that free()-ing a shared page does in fact only remove the relevant owner in
          PhyMemManager, and does not actually free the page for all owners.
        * Check reference counting : if owneradd() is called multiple times, then free() should be
          called the same amount of time before the shared chunk is actually freed.
        * Same tests, but with the kernel as the allocating process, sender, or recipient
        * Check effectiveness of flags, especially the VMEM_FLAGS_SAME one.
    9. kill() test
        * Restart one test which allocates some data, try to kill a process, check that all of its
          data has been liberated.
        * Same thing, but with the kernel. Check that its data has *not* been liberated.
    a. Pooled allocation
        * Check that set_pool() sets up pooled allocation with a given pool, that it is then used by
          malloc()
        * Check that leave_pool() desactivates pooled allocation and returns the current state of
          the pool
    b. Internal allocator
        * Check that sizeof(MallocMap), sizeof(KnlMallocMap) and sizeof(MallocPIDList) are powers of
          2, and that sizeof(MallocMap) == sizeof(KnlMallocMap) (going from one to the other should
          be a matter of casting a pointer)
        * Count the number of free_mapitems
        * Allocate that number of bytes to a process which already owns a byte of data, one by one
        * Check that the state of VirMemManager and PhyMemManager has not changed and that
          free_mapitems is now empty
        * Allocate one more byte, check the number of newly created free_mapitems and the proper
          allocation of a new physical page where they are stored
        * Free everything, check that the free_mapitems go back at their place and are cleaned up
          before being put there
        * Same tests, but with the kernel as the allocating process
        * Same tests, but with different PIDs at each time, in order to test the management of
          free_listitems