Milestone 1 : Booting in a Bochs

    * Start up an ELFx86 executable (the "boostrap kernel") in bochs using GRUB - DONE
    * Prepare a pack of useful data for the 64 bit kernel. - DONE
    * Prepare 64-bit kernel startup (stack setup, C++ handling, header parsing...)
    * Boot the 64-bit kernel.


Milestone 2 : Debug mode ON

    * Get a "fill" method for quickly filling a region of memory with one byte (like 0x00) and a "copy" method for quickly copying data from a region of memory to another.
    * Be able to erase contents of the screen.
    * Provide a way to text displaying in a cout-like fashion. Allow color and absolute/relative cursor positioning.
    * Get full support for Bochs debugger


Milestone 3 : Interruptions and exceptions management

    * Get support for legacy interruptions and exceptions (keyboard, stack overflow, general protection fault, and the like). Allow specifying of an arbitrary handler for them.
    * Make keyboard-related debugging methods : cin-like functions plus ability to wait for the user to press a key before doing something.
    * Test clock and buzzer handling.
    * Get support for "exotic" interrupts : APIC, IO-APIC, et friends.


Milestone 4 : Physical memory management

    * Enable paging with 4KB/4MB pages. Set up identity mapping (have paging managed as if it wasn't enabled, with page A = memory region A).
    * Use bootstrap information to tell which pages are initially free and which pages are initially reserved. Keep some space to tell which process uses these pages.
    * Create a page allocation and liberation mechanism. Introduce a way to be granted access to a specific page, and to allow sharing when such a behavior is wanted.
    * Make said mechanism safe : manage memory outage events and make required parts of allocation functions atomic.
    * Create a memory chunk allocation and liberation mechanism based on the preceding mechanism and make it safe.
    * Introduce more advanced memory management : Copy-on-Write and full page flags management.


Milestone 5 : Processor state and multiple processors

    * Prepare thread support : allow processor state saving and task switching.
    * Manage multiple cores, aka "application processors" : wake them up, give them something to do, and get full AP management using AMD/Intel manuals
    * Introduire synchronization primitives and atomic operations through mutexes, semaphores, and barriers.
    * Make all operations which need it atomic, including debug routines.